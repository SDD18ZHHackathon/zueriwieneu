)
# create vocabulary
vocab = create_vocabulary(iterator
, stopwords = tm::stopwords() # use stopwords from tm package
#, ngram = c(1, 2) # adds all possible 2-grams
)
vocab
# vocabulary can be pruned
vocab_pruned <- prune_vocabulary(vocab
, term_count_min = 2
, doc_proportion_min = 0.001
, doc_proportion_max = 0.5)
vocab_pruned
# vocabulary can be pruned
vocab_pruned <- prune_vocabulary(vocab
, term_count_min = 50
, doc_proportion_min = 0.001
, doc_proportion_max = 0.5)
vocab_pruned
# create a vectorizer function
vectorizer <- vocab_vectorizer(vocab_pruned)
# collocations ------------
# collocation models
collocation_model <- Collocations$new(
collocation_count_min = 50 # only consider set of words as phrase if it will observe it at least n times
, pmi_min = 5
, lfmd_min = -Inf
, gensim_min = 0
)
collocation_model$fit(iterator, n_iter = 5) # repeats 2 times to get 3 word collocations
# inspect collocation object
collocation_model$collocation_stat
temp
# apply collocation_model on new data set
temp <- collocation_model$transform(iterator)
temp
# create new iterator by applying collocation_model on new data set
iterator_w_collocations <- collocation_model$transform(iterator)
iterator$nextElem()$tokens[[1]] # vector of 1st documents tokens
iterator_w_collocations$nextElem()$tokens[[1]]
# use this to create new vocabulary
vocab_w_collocations <- create_vocabulary(iterator_w_collocations)
vocab_w_collocations
vocab_w_collocations[startsWith(vocab_w_collocations$term, 'alfa')]
vocab_w_collocations[startsWith(vocab_w_collocations$term, 'alfa'),]
vocab_w_collocations[startsWith(vocab_w_collocations$term, 'alfa_'),]
vocab_w_collocations[startsWith(vocab_w_collocations$term, 'new_'),]
tcm = create_tcm(iterator_w_collocations, vocab_vectorizer(vocab_w_collocations))
tcm
glove = Glove$new(50, vocabulary = vocab_w_collocations, x_max = 50)
glove = GloVe$new(50, vocabulary = vocab_w_collocations, x_max = 50)
temp = glove$fit_transform(tcm, 10)
temp
class(temp)
dim(temp)
wv_context = glove$components
word_vectors = temp + t(wv_context)
cos_sim = sim2(x = word_vectors, y = word_vectors['mann',,drop = F], method = "cosine", norm = "l2")
head(sort(cos_sim[,1], decreasing = TRUE), 5)
cos_sim = sim2(x = word_vectors, y = word_vectors['kaffee',,drop = F], method = "cosine", norm = "l2")
head(sort(cos_sim[,1], decreasing = TRUE), 5)
cos_sim = sim2(x = word_vectors, y = word_vectors['berlin',,drop = F], method = "cosine", norm = "l2")
head(sort(cos_sim[,1], decreasing = TRUE), 5)
outpath <- '/Users/Samuel/Dropbox/Data_Projects/Fake_News/'
library(xml2)
library(tidyr)
library(dplyr)
library(purrr)
library.install('tidyverse')
install.packages('tidyverse')
library(xml2)
library(tidyr)
library(dplyr)
library(purrr)
outpath
outpath <- '/Users/Samuel/Dropbox/Data_Projects/Fake_News/WebScraping/'
load(paste0(outpath,'input.Rda'))
load(paste0(outpath,'input.Rda'))
outpath <- '/Users/Samuel/Dropbox/Data_Projects/Fake_News/data/'
load(paste0(outpath,'input.Rda'))
# export
text_file <- file(paste0(outpath, 'text_input.txt'))
writeLines(paste(text, collapse = '\n'), text_file)
close(text_file)
title_file <- file(paste0(outpath, 'title_input.txt'))
writeLines(paste(title, collapse = '\n'), title_file)
close(title_file)
library(keras)
use_python('/Users/Samuel/VirtualenvTensorFlow/bin/python', required = TRUE)
py_config()
library(reticulate)
py_config()
use_python('/Users/Samuel/VirtualenvTensorFlow/bin/python', required = TRUE)
py_config()
?use_virtualenv
use_virtualenv('/Users/Samuel/VirtualenvTensorFlow', required = TRUE)
py_config()
library(reticulate)
use_virtualenv('/Users/Samuel/VirtualenvTensorFlow', required = TRUE)
py_config()
?initialize_python
props <- lapply(data_raw$features, function(x) x[['properties']]) %>% as_tibble()
library(reticulate)
py_config()
library(reticulate)
py_config()
library(reticulate)
use_virtualenv('/Users/Samuel/VirtualenvTensorFlow', required = TRUE)
py_config()
library(reticulate)
use_virtualenv('/Users/Samuel/VirtualenvTensorFlow', required = TRUE)
py_config()
library(reticulate)
use_virtualenv('/Users/Samuel/VirtualenvKeras', required = TRUE)
use_virtualenv('/Users/Samuel/VirtualenvKeras', required = TRUE)
library(reticulate)
use_virtualenv('/Users/Samuel/VirtualenvKeras', required = TRUE)
use_virtualenv('/Users/Samuel/VirtualenvTensorFlow', required = TRUE)
py_config()
use_virtualenv('/Users/Samuel/VirtualenvKeras', required = TRUE)
virtualenv_list()
install.packages('jsonlite')
library(reticulate)
use_python('/usr/local/Cellar/python3/3.7.0/bin')
py_config()
use_python('/usr/local/Cellar/python3/3.7.0/bin', required = TRUE)
py_config()
library(reticulate)
use_python('/usr/local/Cellar/python3/3.7.0/bin', required = TRUE)
py_config()
?use_python
library(jsonlite)
library(tidyverse)
library(tm)
library(SnowballC)
library(Matrix)
library(caret)
load('dataset_split.Rda')
load('predictions_datasets.Rda')
# set working directory
setwd("~/Dropbox/Data_Projects/SDD_Hackathon")
load('dataset_split.Rda')
load('predictions_datasets.Rda')
# train layer 2 model
control <- trainControl(method="cv"
, number=2
, allowParallel = FALSE
, verboseIter = TRUE
, classProbs = TRUE
)
model <- train(y = as.factor(dataset2$service_name)
, x = as.data.frame(pred2)
, method="ranger"
, metric="Kappa"
, trControl=control
#tuneGrid=tunegrid,
#params=params
)
print(model)
# final validation
final_pred <- predict(model, pred3, type = 'raw')
final_pred
final_pred_cat <- predict(model, pred3, type = 'prob')
final_pred_cat
table(final_pred, dataset3$service_name)
sum(diag(as.matrix(table(final_pred, dataset3$service_name))))/sum(as.matrix(table(final_pred, dataset3$service_name)))
final_pred_cat <- predict(model, pred3, type = 'prob') %>% add_column(dataset3$service_name)
final_pred_cat
final_pred_cat <- predict(model, pred3, type = 'prob') %>% add_column(y_true = dataset3$service_name)
final_pred_cat <- as_tibble(predict(model, pred3, type = 'prob')) %>% add_column(y_true = dataset3$service_name)
final_pred_cat
temp <- sapply(final_pred_cat, function(x) length(x))
temp <- apply(final_pred_cat, 1, function(x) length(x))
temp <- apply(final_pred_cat, 1, function(x) as.numeric(substr(3,1,x[9])) %in% order(x[1:8], decreasing = TRUE)[1:3])
warnings()
substr(3,1,'cat1')
?substr
substr('cat1',3,1)
substr('cat1',3,4)
substr('cat1',4,4)
temp <- apply(final_pred_cat, 1, function(x) as.numeric(substr(x[9],4,4)) %in% order(x[1:8], decreasing = TRUE)[1:3])
table(temp)
sum(temp)/length(temp)
temp <- apply(final_pred_cat, 1, function(x) as.numeric(substr(x[9],4,4)) %in% order(x[1:8], decreasing = TRUE)[1:2])
sum(temp)/length(temp)
temp <- apply(final_pred_cat, 1, function(x) as.numeric(substr(x[9],4,4)) %in% order(x[1:8], decreasing = TRUE)[1])
sum(temp)/length(temp)
names(dataset1)
library(reticulate)
use_python('/usr/local/Cellar/python/3.7.0/bin/python3', required = TRUE)
py_config()
source_python('python_desc_model.py')
presentation_model <- train_model(data_total$detail, data_total$service_name)
# read url and convert to data.frame
url <- 'https://data.stadt-zuerich.ch/dataset/zueriwieneu_meldungen/resource/2fee5562-1842-4ccc-a390-c52c9dade90d/download/zueriwieneu_meldungen.json'
dataZWN <- fromJSON(txt=url)
str(dataZWN)
dataZWN_df<-dataZWN$features$properties %>% as_tibble()
# prepare data
data_total <- mutate(dataZWN_df, service_name = case_when(service_name == 'Abfall/Sammelstelle' ~ 'Cat1',
service_name == 'Strasse/Trottoir/Platz' ~ 'Cat2',
service_name == 'Signalisation/Lichtsignal' ~ 'Cat3',
service_name == 'Grünflächen/Spielplätze' ~ 'Cat4',
service_name == 'Beleuchtung/Uhren' ~ 'Cat5',
service_name == 'Graffiti' ~ 'Cat6',
service_name == 'VBZ/ÖV' ~ 'Cat7',
service_name == 'Brunnen/Hydranten' ~ 'Cat8',
TRUE ~ 'Error')
, interface = case_when(interface_used == 'Web interface' ~ 'Web'
, interface_used == 'iOS' ~ 'iOS'
, interface_used == 'Android' ~ 'Android'
, interface_used == 'iPhone' ~ 'iOS'
, interface_used == 'iPad' ~ 'iOS'
, interface_used == 'iPod touch' ~ 'iOS'))
presentation_model <- train_model(data_total$detail, data_total$service_name)
presentation_models <- train_model(data_total$detail, data_total$service_name)
predict_category <- function(text){
pred <- predict(text, presentation_models)
return(pred)
}
predict_category('hello there')
predict_category <- function(text){
pred <- predict(c(text), presentation_models)
return(pred)
}
predict_category('hello there')
predict_category <- function(text){
pred <- predict(c(text, text), presentation_models)
return(pred)
}
predict_category('hello there')
pred <- predict(c(text, text), presentation_models)[1]
predict_category('hello there')
predict_category <- function(text){
pred <- predict(c(text, text), presentation_models)[1]
return(pred)
}
predict_category('hello there')
case_when(service_name == 'Abfall/Sammelstelle' ~ 'Cat1',
service_name == 'Strasse/Trottoir/Platz' ~ 'Cat2',
service_name == 'Signalisation/Lichtsignal' ~ 'Cat3',
service_name == 'Grünflächen/Spielplätze' ~ 'Cat4',
service_name == 'Beleuchtung/Uhren' ~ 'Cat5',
service_name == 'Graffiti' ~ 'Cat6',
service_name == 'VBZ/ÖV' ~ 'Cat7',
service_name == 'Brunnen/Hydranten' ~ 'Cat8',
TRUE ~ 'Error')
pred == 'Cat2'
pred = 'Cat2'
case_when(pred == 'Abfall/Sammelstelle' ~ 'Cat1',
pred == 'Strasse/Trottoir/Platz' ~ 'Cat2',
pred == 'Signalisation/Lichtsignal' ~ 'Cat3',
pred == 'Grünflächen/Spielplätze' ~ 'Cat4',
pred == 'Beleuchtung/Uhren' ~ 'Cat5',
pred == 'Graffiti' ~ 'Cat6',
pred == 'VBZ/ÖV' ~ 'Cat7',
pred == 'Brunnen/Hydranten' ~ 'Cat8',
TRUE ~ 'Error')
predict_category <- function(text){
pred <- predict(c(text, text), presentation_models)[1]
return(case_when(pred == 'Cat1' ~ 'Abfall/Sammelstelle',
pred == 'Cat2' ~  'Strasse/Trottoir/Platz',
pred == 'Cat3' ~  'Signalisation/Lichtsignal',
pred == 'Cat4' ~  'Grünflächen/Spielplätze',
pred == 'Cat5' ~  'Beleuchtung/Uhren',
pred == 'Cat6' ~  'Graffiti',
pred == 'Cat7' ~  'VBZ/ÖV',
pred == 'Cat8' ~  'Brunnen/Hydranten',
TRUE ~ 'No comment on this one...'))
}
predict_category('hello there')
library(shiny)
predict_category('abfall auf der strasse')
predict_category('abfall auf der strasse und ein graffiti auf der wand')
predict_category('abfall auf der strasse und ein graffiti auf der wand, abfall du vollidiot')
predict_category('abfall auf der strasse und ein graffiti auf der wand, abfall du vollidiot, ABFALL!!')
ui <- fluidPage(
titlePanel('SDD Hackathon Züri Wie Neu Challenge'),
mainPanel(
textInput(inputID = 'text'),
textOutput('cat')
)
)
shinyApp(ui, server)
server <- function(input, output){
output$cat <- renderText(predict_category(input$text))
}
ui <- fluidPage(
titlePanel('SDD Hackathon Züri Wie Neu Challenge'),
mainPanel(
textInput(inputID = 'text'),
textOutput('cat')
)
)
shinyApp(ui, server)
ui <- fluidPage(
titlePanel('SDD Hackathon Züri Wie Neu Challenge'),
mainPanel(
textInput(inputID = 'text'),
textOutput('cat')
)
)
ui <- fluidPage(
titlePanel('SDD Hackathon Züri Wie Neu Challenge'),
mainPanel(
textInput(inputId = 'text'),
textOutput('cat')
)
)
ui <- fluidPage(
titlePanel('SDD Hackathon Züri Wie Neu Challenge'),
mainPanel(
textInput(inputId = 'text', label = 'Bitte eine Beschreibung des Schadens angeben'),
textOutput('cat')
)
)
server <- function(input, output){
output$cat <- renderText(predict_category(input$text))
}
shinyApp(ui, server)
runApp()
runApp()
?column
runApp()
runApp()
?bootstrapPage
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?img
?img
img()
img('')
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?fluidPage
?bootstrapPage
runApp()
runApp()
runApp()
install.packages('shinythemes')
library(shinythemes)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
source_python('python_desc_model.py')
predict_category <- function(text){
pred <- predict(c(text, text), presentation_models)[1]
return(case_when(pred == 'Cat1' ~ 'Abfall/Sammelstelle',
pred == 'Cat2' ~  'Strasse/Trottoir/Platz',
pred == 'Cat3' ~  'Signalisation/Lichtsignal',
pred == 'Cat4' ~  'Grünflächen/Spielplätze',
pred == 'Cat5' ~  'Beleuchtung/Uhren',
pred == 'Cat6' ~  'Graffiti',
pred == 'Cat7' ~  'VBZ/ÖV',
pred == 'Cat8' ~  'Brunnen/Hydranten',
TRUE ~ 'No comment on this one...'))
}
predict_category('test')
source_python('python_desc_model.py')
presentation_models <- train_model(data_total$detail, data_total$service_name)
predict_category <- function(text){
pred <- predict(c(text, text), presentation_models)[1]
return(case_when(pred == 'Cat1' ~ 'Abfall/Sammelstelle',
pred == 'Cat2' ~  'Strasse/Trottoir/Platz',
pred == 'Cat3' ~  'Signalisation/Lichtsignal',
pred == 'Cat4' ~  'Grünflächen/Spielplätze',
pred == 'Cat5' ~  'Beleuchtung/Uhren',
pred == 'Cat6' ~  'Graffiti',
pred == 'Cat7' ~  'VBZ/ÖV',
pred == 'Cat8' ~  'Brunnen/Hydranten',
TRUE ~ 'No comment on this one...'))
}
predict_category('abfall')
source_python('python_desc_model.py')
presentation_models <- train_model(data_total$detail, data_total$service_name)
predict_category <- function(text){
pred <- predict(c(text, text), presentation_models)[1]
return(case_when(pred == 'Cat1' ~ 'Abfall/Sammelstelle',
pred == 'Cat2' ~  'Strasse/Trottoir/Platz',
pred == 'Cat3' ~  'Signalisation/Lichtsignal',
pred == 'Cat4' ~  'Grünflächen/Spielplätze',
pred == 'Cat5' ~  'Beleuchtung/Uhren',
pred == 'Cat6' ~  'Graffiti',
pred == 'Cat7' ~  'VBZ/ÖV',
pred == 'Cat8' ~  'Brunnen/Hydranten',
TRUE ~ 'No comment on this one...'))
}
predict_category('abfall')
predict(c('text', 'abfall'), presentation_models)
pred <- predict(c(text, text), presentation_models)[1,]
predict(c('text', 'abfall'), presentation_models)[1]
predict(c('text', 'abfall'), presentation_models)[1,]
pred <- predict(c('text', 'abfall'), presentation_models)[1,]
pred
which.max(pred)
predict_category2 <- function(text){
pred <- predict(c(text, text), presentation_models)[1,]
cat <- which.max(pred)
return(paste(case_when(cat == 1 ~ 'Abfall/Sammelstelle',
cat == 2 ~  'Strasse/Trottoir/Platz',
cat == 3 ~  'Signalisation/Lichtsignal',
cat == 4 ~  'Grünflächen/Spielplätze',
cat == 5 ~  'Beleuchtung/Uhren',
cat == 6 ~  'Graffiti',
cat == 7 ~  'VBZ/ÖV',
cat == 8 ~  'Brunnen/Hydranten',
TRUE ~ 'No comment on this one...'),max(pred)))
}
predict_category2(c('abfall'))
predict_category2(c('abfall test test'))
?format
?sprintf
predict_category2 <- function(text){
pred <- predict(c(text, text), presentation_models)[1,]
cat <- which.max(pred)
return(paste(case_when(cat == 1 ~ 'Abfall/Sammelstelle',
cat == 2 ~  'Strasse/Trottoir/Platz',
cat == 3 ~  'Signalisation/Lichtsignal',
cat == 4 ~  'Grünflächen/Spielplätze',
cat == 5 ~  'Beleuchtung/Uhren',
cat == 6 ~  'Graffiti',
cat == 7 ~  'VBZ/ÖV',
cat == 8 ~  'Brunnen/Hydranten',
TRUE ~ 'No comment on this one...'),sprintf('%f1.1%',max(pred))))
}
predict_category2(c('abfall test test'))
predict_category2 <- function(text){
pred <- predict(c(text, text), presentation_models)[1,]
cat <- which.max(pred)
return(paste(case_when(cat == 1 ~ 'Abfall/Sammelstelle',
cat == 2 ~  'Strasse/Trottoir/Platz',
cat == 3 ~  'Signalisation/Lichtsignal',
cat == 4 ~  'Grünflächen/Spielplätze',
cat == 5 ~  'Beleuchtung/Uhren',
cat == 6 ~  'Graffiti',
cat == 7 ~  'VBZ/ÖV',
cat == 8 ~  'Brunnen/Hydranten',
TRUE ~ 'No comment on this one...'),sprintf('%1.1f%%',max(pred))))
}
predict_category2(c('abfall test test'))
predict_category2 <- function(text){
pred <- predict(c(text, text), presentation_models)[1,]
cat <- which.max(pred)
return(paste(case_when(cat == 1 ~ 'Abfall/Sammelstelle',
cat == 2 ~  'Strasse/Trottoir/Platz',
cat == 3 ~  'Signalisation/Lichtsignal',
cat == 4 ~  'Grünflächen/Spielplätze',
cat == 5 ~  'Beleuchtung/Uhren',
cat == 6 ~  'Graffiti',
cat == 7 ~  'VBZ/ÖV',
cat == 8 ~  'Brunnen/Hydranten',
TRUE ~ 'No comment on this one...'),sprintf('%1.1f%%',100*max(pred))))
}
predict_category2(c('abfall test test'))
runApp()
ui <- fluidPage(
bootstrapPage(theme = shinytheme('superhero'),
fluidRow(
column(12,
align = 'center',
titlePanel('Swiss Digital Day 2018 Hackathon'),
h3('Züri Wie Neu Challenge'), br(), br(),
img('', src = 'Logo_128.png'), br(), br(),
textInput(inputId = 'text', label = 'Bitte eine Beschreibung des Schadens angeben'),
textOutput('cat')
)
)
)
)
server <- function(input, output){
output$cat <- renderText(if(input$text == ''){''}else{predict_category2(input$text)})
}
shinyApp(ui, server)
ui <- fluidPage(
bootstrapPage(theme = shinytheme('superhero'),
fluidRow(
column(12,
align = 'center',
titlePanel('Swiss Digital Day 2018 Hackathon'),
h3('Züri Wie Neu Challenge'), br(), br(),
img('', src = 'Logo_128.png'), br(), br(),
textInput(inputId = 'text', label = 'Bitte eine Beschreibung des Schadens angeben'),
textOutput('cat')
)
)
)
)
server <- function(input, output){
output$cat <- renderText(if(input$text == ''){''}else{predict_category2(input$text)})
}
shinyApp(ui, server)
server <- function(input, output){
output$cat <- renderText(if(input$text == ''){''}else{predict_category(input$text)})
}
shinyApp(ui, server)
